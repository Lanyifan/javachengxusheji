# 第四章 面向对象程序设计

## 第一节 类和对象

[填空]类的定义也称为类的声明。类中含有两部分元素,分别是数据成员变量和成员方法。

[程序设计]类定义的一般格式如下:

```
修饰符 class 类名[extends父类名]{
    修饰符 类型 成员变量1;
    修饰符 类型 成员变量2;
    修饰符 类型 成员方法1(参数列表){
        方法体
    }
修饰符 类型 成员方法2(参数列表){
        方法体
    }
    ......
}
```

其中, class是关键字,表明其后定义的是一个类。含有class 的这一行称为类头,后面大括号括住的部分称为类体。class前的修饰符可以有多个,用来限定所定义的类的使用方式。类名是用户为该类所起的名字,它必须是一个合法的标识符,并尽量遵从命名约定。extends是关键字。如果所定义的类是从某一个父类派生而来,那么,父类的名字要写在extends之后。

[单选、填空]类定义中的修饰符是访问权限修饰符,包括 `public`、`private`和 `protected`,也可以不写,表示是默认修饰符。它们既可以用来修饰类,又可以修饰类中的成员,修饰符决定所修饰成员在程序运行时被访问的方式。访问权限关键字与访问能力之间的关系见表4-1。
表 4-1访问权限修饰符

| 类型             | 无修饰符 | private | protected | public |
| ---------------- | -------- | ------- | --------- | ------ |
| 同一类           | 是       | 是      | 是        | 是     |
| 同一包中的子类   | 是       | 否      | 是        | 是     |
| 同一包中的非子类 | 是       | 否      | 是        | 是     |
| 不同包中的子类   | 否       | 否      | 是        | 是     |
| 不同包中的非子类 | 否       | 否      | 否        | 是     |

[填空]构造方法的名字与类名相同,没有返回值,在创建对象实例时通过new运算符自动调用。同时为了便于创建实例,一个类可以有多个具有不同参数列表的构造方法，即构造方法可以重载。

[单选]构造方法不能说明为 `native`、`abstract`、`synchronized`或 `final`类型,通常说明为public类型的。

[单选、填空]每个类都必须至少有一个构造方法。如果程序员没有为类定义构造方法,系统就会自动为该类生成一个默认的构造方法。默认构造方法的参数列表及方法体均为空,所生成的对象的各属性值也为零或空。如果类定义中已经含有一个或多个构造方法,则系统不会再自动生成默认的构造方法了。

[填空]this除了可以用在构造方法中之外,还可以用来指明要操作的对象自身。

[单选、填空]创建对象实例的格式如下:

`变量名 = new 类名(参数列表);`

也可以与变量声明合在一起使用。`类名 变量名 = new 类名(参数列表);`

当通过new为一个对象分配内存时,如果构造方法中没有为成员变量提供初值,则Java进行自动初始化。对于数值变量,赋初值0;对于布尔变量,赋初值false;对于引用,即对象类型的任何变量,使用一个特殊的值null作为初值。

[填空]定义类时,可以对成员变量进行显式的初始化,即在声明这些变量的同时,直接给出它们的初值。

## 第二节 定义方法

[单选、填空]对对象的操作体现在成员方法上。说明为 private的成员变量,在类外,不能通过点操作符直接访问,必须通过成员方法才能访问。

[简答]关于方法定义的说明:

(1)方法名必须是一个合法的标识符。

(2)返回类型是方法返回值的类型。如果方法不返回任何值,则应该声明为void。

Java对待返回值的要求很严格,方法返回值必须与所声明的类型相匹配。如果方法声明有返回值,比如说是int,那么方法从任何一个分支返回时都必须返回一个整数值。

(3)修饰符段可以含有几个不同的修饰符,其中限定访问权限的修饰符包括public、protected和private。

(4)参数列表是传送给方法的参数表。表中各元素间以逗号分隔,每个元素由一个类型和一个标识符表示的参数组成。

(5)块表示方法体,是要实际执行的代码段,是由一对大括号括起来的语句序列。方法体中一般使用return语句表示方法的结束。如果方法的返回类型不是void,则需要在return语句中指明方法的返回值。

[填空]调用方法时,通常会给方法传递一些值。传给方法的值称为实参,方法的参数列表中列出的值称为形参。

[程序分析、程序设计]Java“按值”传送实参:

(1)如果形参是基本数据类型的,则调用方法时,将实参的“值”复制给形参。返回时,形参的值并不会带回给实参,即在方法内对形参的任何修改,都不会影响实参的值。

(2)如果形参是引用,则调用方法时传递给形参的是一个地址,即实参指向的对象的首地址。方法返回时,这个地址也不会被改变,但地址内保存的内容是可以改变的。因此,当从方法中退出时,所修改的对象内容可以保留下来。

[填空]允许多个方法使用同一个方法名,这就是方法名的重载。

[单选、填空]一般地,方法名称加上方法的参数列表(包括方法中参数的个数、顺序和类型)称为方法签名。方法重载时,方法签名一定不能相同。

[简答]重载方法有两条规则:

(1)调用语句的实参列表必须足够判断要调用的是哪个方法。实参的类型可能要进行正常的扩展提升(如浮点数变为双精度数),但在有些情况下会引起混淆。

(2)方法的返回类型可以相同也可以不同。两个同名方法仅有返回类型不同,而参数列表完全相同,这是不够的,因为在方法执行前不知道能得到什么类型的返回值,因此也就不能确定要调用哪个方法。重载方法的参数列表必须不同。

## 第三节 静态成员

[单选、填空]在类的定义中还可以定义一种特殊的成员,用static修饰,称为静态成员或类成员,包括静态变量和静态方法。静态成员是不依赖于特定对象的内容。

[填空]将一个变量定义为静态变量的方法就是将这个变量标记上关键字static

[单选、填空]与静态变量类似,如果需要在尚未创建一个对象实例的时候就去引用方法的程序代码,那么标记上关键字static即可实现。这样的方法称为静态方法,或称类方法。与之相对的,非静态方法有时也称为实例方法。静态方法不依赖于特定对象的行为。

[简答]使用静态方法时,有两个特别的限制必须注意:

(1)由于静态方法可以在没有定义它所从属的类的对象的情况下加以调用,故不存在this值。因此,一个静态方法只能使用其内部定义的参数或静态变量,如果想使用非静态变量将引起编译错误。

(2)静态方法不能被重写。也就是说,在这个类的后代类中,不能有相同名称、相同参数列表的方法。

## 第四节 包装类

[单选、填空]对于Java中的每种基本数据类型,Java类库中都有一个对应的包装类。所有的包装类都定义在java.lang包中。表4-2列出了每种基本数据类型及其对应的包装类。
表4-2 java.lang包中的包装类

| 基本数据类型                                                                                             | 包装类  | 基本数据类型 | 包装类    |
| -------------------------------------------------------------------------------------------------------- | ------- | ------------ | --------- |
| byte                                                                                                     | Byte    | double       | Double    |
| short                                                                                                    | Short   | char         | Character |
| int                                                                                                      | Integer | boolean      | Boolean   |
| void                                                                                                     | Void    | long         | Long      |
| float                                                                                                    | Float   |              |           |
| 注意,对应于void类型的包装类是Void。但和其他的包装类不一样的是, Void类不能被实例化,只表示void引用的概念。 |         |              |           |

[填空]自动将基本数据类型转换为对应的包装类的过程称为自动装箱。逆向的转换称为拆箱,需要时也是自动完成的。自动装箱与自动拆箱仅能用在基本数据类型与对应的包装类之间。其他的情况,如将基本数据类型赋给对象引用变量,或是相反的过程,都会导致编译错误。
