# 第六章 继承与多态

## 第一节 子类

[程序分析、程序设计]具有一般性和特殊性的两个类:

```
public class Employee {//具有一般性的类
    private String name , jobTitle;
    private DatehireDate, dateOfBirth;
    private int grade;
    ...
}
public class Manager {//具有特殊性的类
    private String name , jobTitle;
    private DatehireDate , dateOfBirth;
    private int grade;//以上是与Employee共有的属性private String department;//特有的属性
    private Employee[] subordinates;//特有的属性...
    ...
}
```

从上面的定义可以看出, Manager类和Employee类之间存在重复部分。实际上,适用于 Employee的很多属性和方法可以不经修改就被Manager所使用。Manager与 Employee之间存在“is a”关系,即Manager"is a”Employee。

[单选、填空]与一般的面向对象语言一样,Java提供了派生机制,允许程序员用以前已定义的类来定义一个新类。新类称作**子类**,原来的类称作**父类**,也称为**基类**或**超类**。两个类中共同的内容放到父类中,特殊的内容放到子类中。在定义类时可以表明一个类是不是另一个类的子类。在Java中,用关键字extends表示派生,格式如下:

```
修饰符 class 子类名 extends 父类名1{
    类体
}
```

[单选、填室]0bject类是Java程序中所有类的直接或间接父类,处在类层次的最高点。所有其他的类都是从 Object类派生而来的。

[简答]Object类包含了所有Java类的公共属性,其构造方法是0bject(),类中主要的方法如下:

(1)public final Class getClass():获取当前对象所属的类信息,返回Class对象。

(2)public String toString(）:按字符串对象返回当前对象本身的有关信息。

(3)public Boolean equals (Object obj):比较两个对象是否是同一个对象,是则返回true。

[填空]关于对象相等的判别,在Java中有两种方式。一种是使用==运算符,另一种是使用equals()方法。

[填空]Java是完全的面向对象语言,具有完全的OOP能力。在类的继承机制中,它抛弃了多重继承功能,仅实现了单重继承机制。

[填空]多重继承是指**从多个类共同派生一个子类,即一个类可以有多个父类**。

[填空]和大多数面向对象的语言一样,Java允许使用对象的父类类型的一个变量指向该对象,比如对于前面定义的Employee类和 Manager类,可以将子类的对象赋给父类的变量:

`Employee e = new Manager();//子类 Manager的实例赋给父类变量e`

这称为对象转型(Casting)。

[简答]一般地,进行对象引用转型时的规则:

(1)沿类层次向“上”转型总是合法的,例如,把 Manager引用转型为Employee引用。此种方式下不需要转型运算符,只用简单的赋值语句就可以完成。

(2)对于向“下”转型,只能是祖先类转型到后代类,其他类之间是不允许的。

## 第二节 方法覆盖与多态

[单选、填空]在面向对象语言程序设计中,方法覆盖是经常用到的概念。通过方法覆盖,可以达到语言多态性的目的。当子类中要做的事情(某个方法)与父类中不完全相同时,就要重写父类中的相关方法。

[单选、填空]如果方法名相同,而参数列表不同,则是对方法的重载。调用重载方法时，编译器将根据参数的个数和类型,选择对应的方法执行。重载的方法属于同一个类,覆盖的方法分属于父类、子类中。

[简答]应用覆盖时必须注意的两条重要规则:

(1)**覆盖方法的允许访问范围不能小于原方法**。

(2)**覆盖方法所抛出的异常不能比原方法更多**。

以上两条规则均源于多态性和Java所具有的“类型安全性”的要求。

[填空]如果在子类构造方法的定义中调用了父类的构造方法,则调用语句必须出现在子类构造方法的第一行。

[单选、填空]在Java中,多态是一个重要概念。有了多态，能够允许同一条方法调用指令在不同的上下文中做不同的事情。

[单选、填空]调用稍后可能被覆盖的方法的这种处理方式,称为动态绑定或后绑定。动态绑定一定要到运行时才能确定要执行的方法代码。在编译过程中能确定调用方法的处理方式,称为静态绑定或前绑定。

## 第三节 终极类与抽象类

[填空]Java中有一个重要的关键字final,它表示终极,既可以修饰一个类,也可以修饰类中的成员变量或成员方法。

[填空]被标记为final的类将不能被继承,这样的类称为**终极类**或**终态类**,其声明的格式为:

```
final class终极类名{
    类体
}
```

[单选、填空]成员方法也可以被标记为final,从而成为终极方法或终态方法。被标记为final的方法将不能被覆盖,从而可以确保被调用的方法是最原始的方法,而不是已被更改的子类中的方法。另外,**把方法标记为final有时也被用于优化,从而提高编译运行效率**。终极方法的定义格式为:

```
final 返回值类型 终极方法名([参数列表]){
    方法体
}
```

[填空]一个变量被标记为final,称为终极变量或终态变量。实际上它会成为一个常量。企图改变终极变量的值将引起编译错误。

[填空]在Java中可以通过关键字abstract把一个类定义为抽象类,每一个未被定义具体实现的方法也应标记为abstract,这样的方法称为抽象方法。

[程序设计]抽象类和抽象方法的定义格式为:

```
public abstract class 抽象类名1{//抽象类
    类体
}
public abstract 返回值类型 抽象方法名([参数列表]);//抽象方法
```

## 第四节 接口

[填空、程序设计]接口的定义格式为:

```
[接口修饰符] interface 接口名[extends父接口列表]{
    …//方法原型或静态常量
```

接口与一般类一样,本身也具有数据成员变量与方法,但数据成员变量一定要赋初值,且此值不能再更改,而方法必须是“抽象方法”。

[单选、填空]接口的实现与类的继承是相似的,不过,实现接口的类不能从该接口的定义中继承任何行为。在实现该接口的类的任何对象中,都能够调用这个接口中定义的方法。一个类可以同时实现多个接口。

要实现接口,可以在类的声明中用关键字implements来表示。接口中的所有抽象方法必须在类或子类中实现。

[单选、填室]Java程序中,可以在implements后面声明多个接口名,也就是一个类可以实现多个接口。接口实际上就是一个特殊的抽象类,同时实现多个接口也就意味着具有多重继承的能力。由于在接口中的方法都是抽象方法,并不包含任何的具体代码,对这些抽象方法的实现都在具体的类中完成,因此,即使不同的接口中有同名的方法,类的实例也不会混绢。这正是 Java取消了显式的多重继承机制,但还保留了多重继承的能力之所在。
