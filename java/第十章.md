# 第十章 多线程

## 第一节 线程和多线程

[单选、填空]在程序要投入运行时,系统从程序入口开始按语句的顺序(包括顺序、分支和循环结构)完成相应指令直至结尾,再从出口退出,整个程序结束。这样的语句结构称为进程,它是程序的一次动态执行,对应了从代码加载、执行至执行完毕的一个完整过程;或者说进程就是程序在处理机中的一次运行。在这样一个结构中不仅包括了程序代码,同时也包括了系统资源的概念。具体来说,一个进程既包括其所要执行的指令,又包括执行指令所需的任何系统资源,如CPU、内存空间、I/O端口等,不同进程所占用的系统资源相对独立。

[单选、填空]线程是进程执行过程中产生的多条执行线索,是比进程单位更小的执行单位,在形式上同进程十分相似----都是用一个按序执行的语句序列来完成特定的功能。不同的是,它没有入口,也没有出口,因此其自身不能自动运行,而必须栖身于某一个进程之中,由进程触发执行。在系统资源的使用上,属于同一进程的所有线程共享该进程的系统资源,但是线程之间切换的速度比进程切换要快得多。

[简答]在Java中,线程由以下3部分组成:

(1)虚拟CPU,封装在java. lang. Thread类中,它控制着整个线程的运行。
(2)执行的代码,传递给Thread类,由 Thread类控制按序执行。
(3)处理的数据,传递给Thread类,是在代码执行过程中所要处理的数据。

[单选、填空]线程一共有4种状态,分别是**新建(New)**、**可运行状态(Runnable)**、**死亡( Dead)**及**阻塞(Blocked)**。

## 第二节 创建线程

[填空]创建线程有两种方法,一种是**定义一个继承Thread类的子类**,另一种是**实现Runnable接口**。

[简答]创建线程两种方法的适用条件:

(1)适用于采用实现Runnable接口方法的情况。因为Java只允许单重继承,如果一个类已经继承了Thread,就不能再继承其他类,在一些情况下,这就被迫采用实现Runnable的方法。另外,由于原来的线程采用的是实现 Runnable接口的方法,可能会出于保持程序风格的一贯性而继续使用这种方法。

(2)适用于采用继承Thread方法的情况。当一个run()方法置于Thread类的子类中时, this实际上引用的是控制当前运行系统的Thread实例。

## 第三节 线程的基本控制

[填空]虽然一个线程已经被创建,但它实际上并没有立刻运行。要使线程真正地在Java环境中运行,必须通过方法start()来启动, start()方法也在Thread类中。

[填空]在Java中,线程调度通常是抢占式,而不是时间片式。抢占式调度是指可能有多个线程准备运行,但只有一个在真正运行。一个线程获得执行权,这个线程将持续运行下去,直到它运行结束或因为某种原因而阻塞,再或者有另一个高优先级线程就绪,最后一种情况称为低优先级线程被高优先级线程所抢占。

[简答]每个线程都有一个优先级,Java的线程调度采用如下的优先级策略:
(1)优先级高的先执行,优先级低的后执行。
(2)每个线程创建时都会被自动分配一个优先级,默认时,继承其父类的优先级。
(3)任务紧急的线程,其优先级较高。
(4)同优先级的线程按“先进先出”的调度原则。

[单选、填空]当一个线程从run()方法的结尾处返回时,它自动消亡并且不能再被运行,可以将其理解为自然死亡。另一种情况是遇到异常使得线程结束,可以将其理解为强迫死亡。还可以使用interrupt()方法中断线程的执行。

[填空]有几种方法可以用来暂停一个线程的运行,暂停一个线程也称为挂起。在挂起之后,必须重新唤醒线程进入运行状态,只是线程执行命令的速度非常慢。

## 第四节 线程的互斥

[单选、填空]在Java语言中,引入了“**对象互斥锁**”的概念,也称为**监视器**,使用它来实现不同线程对共享数据操作的同步。“对象互斥锁”阻止多个线程同时访问同一个条件变量。Java可以为每一个对象的实例配有一个“对象互斥锁”。

[简答]在Java语言中,有两种方法可以实现“对象互斥锁”:
(1)用关键字volatile来声明一个共享数据(变量)。

(2)用关键字synchronized来声明操作共享数据的一个方法或一段代码。

## 第五节 线程的同步

[单选、填空]为了解决线程运行速度问题,Java提供了一种建立在对象实例之上的交互方法。Java中的每个对象实例都有两个线程队列和它相连。第一个用来排列等待锁定标志的线程。第二个则用来实现wait()和notify()的交互机制。

[填空]类java.lang. Object 中定义了3个方法,即wait()、notify()和notifyAll()。wait()方法导致当前的线程等待,它的作用是让当前线程释放其所持有的“对象互斥锁”,进入wait队列(等待队列);而notify()/notifyAll()方法的作用是唤醒一个或所有正在等待队列中等待的线程,并将它(们)移入等待同一个“对象互斥锁”的队列。
